Ý tưởng là bạn có thể kiểm tra xem câu trả lời có nhiều nhất là một giá trị nào đó $ m $ trong thời gian $ O (n) $ hay không. Áp dụng tìm kiếm nhị phân trên $ m $, bạn có được giải pháp $ O (n \ log n) $...Làm thế nào để bạn kiểm tra xem câu trả lời có nhiều nhất là $ m $ tại thời điểm $ O (n) $ hay không? Ý tưởng là trình chiếu một cửa sổ có độ dài $ m $ trên mảng của bạn. Nếu tại một thời điểm nào đó tất cả các phần tử bên ngoài cửa sổ đều khác biệt, thì chúng ta đã hoàn tất...Làm thế nào để chúng tôi thực hiện thuật toán trượt này? Gọi $ A $ là mảng ban đầu. Chúng tôi khởi tạo một mảng $ M $ chứa biểu đồ của các phần tử trong $ A_ {m + 1}, \ ldots, A_n $, cũng như số phần tử riêng biệt $ x $. Nếu $ x = n-m $ thì chúng ta đã hoàn tất. Nếu không, chúng tôi sửa đổi $ M $ để chứa biểu đồ của $ A_1, A_ {m + 2}, \ ldots, A_n $:...Chúng tôi xóa một bản sao của phần tử $ A_ {m + 1} $ khỏi $ M $. Nếu tổng số mới của phần tử này là $ 0 $, thì chúng ta giảm $ x $..Chúng tôi thêm một bản sao của phần tử $ A_1 $ vào $ M $. Nếu tổng số mới của phần tử này là $ 1 $, thì chúng ta tăng $ x $....Bằng cách này, chúng tôi có thể cập nhật $ M $ trong thời gian $ O (1) $ mỗi ca...Giải pháp bạn liên kết thực hiện tất cả điều này, ngoài việc duy trì $ x $; điều này được thực hiện tự động bởi cấu trúc dữ liệu bản đồ C ++...Một điểm khác là độ phức tạp về thời gian của giải pháp này, có thể phụ thuộc vào mô hình tính toán chính xác của bạn.
